{"version":3,"sources":["../src/compress.ts","../src/util.ts","../src/index.ts"],"names":[],"mappings":"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","file":"src.1b30d735.js","sourceRoot":"..","sourcesContent":["interface Element {\n    base?: bigint\n    size: bigint\n    value: bigint\n}\nconst baseDelta = (\n    buffer: Element[],\n    limit: bigint,\n    size: bigint,\n    base: bigint,\n) =>\n    buffer.map((element) => {\n        if (element.base !== undefined) {\n            return element\n        }\n        return element.value - base > limit\n            ? {base: undefined, ...element}\n            : {base, size, value: element.value - base}\n    })\n\nconst sizeToLimit = (size: bigint) => {\n    switch (size) {\n        case BigInt(1):\n            return BigInt(0xff)\n        case BigInt(2):\n            return BigInt(0xffff)\n        case BigInt(4):\n            return BigInt(0xffffffff)\n        case BigInt(8):\n            return BigInt(\"0xffffffffffffffff\")\n        default:\n            throw new Error(`${size} should be 1, 2, or 4`)\n    }\n}\n\nconst makeTag = (index: bigint, encoding: bigint, base: bigint) =>\n    (index << BigInt(5)) |\n    (encoding << BigInt(1)) |\n    (base === BigInt(0) ? BigInt(0) : BigInt(1))\n\nconst processTag = (tag: bigint) => ({\n    encoding: (tag >> BigInt(1)) & BigInt(0b1111),\n    index: tag >> BigInt(5),\n    isZeroBase: !((tag & BigInt(1)) === BigInt(0b1)),\n})\n\ninterface CompressionConfig {\n    baseSize: bigint\n    deltaSize: bigint\n    encoding: bigint\n    name: string\n}\nconst compressWith = (\n    buffer: Element[],\n    {baseSize, deltaSize, encoding, name}: CompressionConfig,\n) => {\n    const baseLimit = sizeToLimit(baseSize)\n    const deltaLimit = sizeToLimit(deltaSize)\n\n    const buffer_ = baseDelta(buffer, deltaLimit, deltaSize, BigInt(0))\n    if (buffer_.every((element) => element.base !== undefined)) {\n        return {\n            base: BigInt(0),\n            baseSize,\n            elements: buffer_.map((element, i) => ({\n                ...element,\n                tag: makeTag(BigInt(i), encoding, element.base ?? BigInt(0)),\n            })),\n            size:\n                baseSize +\n                buffer_.reduce((acc, element) => acc + element.size, BigInt(0)),\n        }\n    }\n    const baseIndex = buffer_.findIndex(\n        (element) => element.base === undefined && element.value < baseLimit,\n    )\n    if (baseIndex === -1) {\n        return undefined\n    }\n    buffer_[baseIndex].size = baseSize\n    const final = baseDelta(\n        buffer_,\n        deltaLimit,\n        deltaSize,\n        buffer_[baseIndex].value,\n    )\n    if (!final.every((element) => element.base !== undefined)) {\n        console.log(`Couldn't find compression for ${name}`)\n        return undefined\n    }\n    return {\n        base: buffer_[baseIndex].value,\n        baseSize,\n        elements: final.map((element, i) => ({\n            ...element,\n            tag: makeTag(BigInt(i), encoding, element.base ?? BigInt(0)),\n        })),\n        size:\n            baseSize +\n            final.reduce((acc, element) => acc + element.size, BigInt(0)),\n    }\n}\n\nconst configs: CompressionConfig[] = [\n    {\n        baseSize: BigInt(8),\n        deltaSize: BigInt(1),\n        encoding: BigInt(0b0010),\n        name: \"base8-delta1\",\n    },\n    {\n        baseSize: BigInt(8),\n        deltaSize: BigInt(4),\n        encoding: BigInt(0b0100),\n        name: \"base8-delta4\",\n    },\n    {\n        baseSize: BigInt(8),\n        deltaSize: BigInt(2),\n        encoding: BigInt(0b0011),\n        name: \"base8-delta2\",\n    },\n    {\n        baseSize: BigInt(4),\n        deltaSize: BigInt(2),\n        encoding: BigInt(0b0110),\n        name: \"base4-delta2\",\n    },\n    {\n        baseSize: BigInt(4),\n        deltaSize: BigInt(1),\n        encoding: BigInt(0b0101),\n        name: \"base4-delta1\",\n    },\n    {\n        baseSize: BigInt(2),\n        deltaSize: BigInt(1),\n        encoding: BigInt(0b0111),\n        name: \"base2-delta1\",\n    },\n]\n\nconst bufferToElement = (buffer: BigUint64Array) =>\n    Array.from(new BigInt64Array(buffer)).map((value) => ({\n        size: BigInt(8),\n        value,\n    }))\n\nconst toBytes = (e: bigint, size: bigint) => {\n    const a: number[] = []\n    for (let i = BigInt(0); i < size; ++i) {\n        a.push(Number((e >> (i * BigInt(8))) & BigInt(0xff)))\n    }\n    // return Buffer.from(a)\n    return a.reverse()\n}\n\ninterface CompressedOutput {\n    base: bigint\n    baseSize: bigint\n    elements: {\n        base?: bigint\n        size: bigint\n        tag: bigint\n        value: bigint\n    }[]\n    encoding: bigint\n    name: string\n    size: bigint\n}\n\nexport const tryCompress = (\n    buffer: BigUint64Array,\n): CompressedOutput | undefined => {\n    const elements = bufferToElement(buffer)\n    const runs: CompressedOutput[] = []\n\n    if (buffer.every((x) => x === BigInt(0))) {\n        runs.push({\n            base: BigInt(0),\n            baseSize: BigInt(1),\n            elements: [...buffer].map((value, i) => ({\n                base: BigInt(0),\n                size: BigInt(0),\n                tag: makeTag(BigInt(i), BigInt(0b0000), BigInt(0)),\n                value,\n            })),\n            encoding: BigInt(0b0000),\n            name: \"zeros\",\n            size: BigInt(1),\n        })\n    }\n\n    if (buffer.every((x) => x === buffer[0])) {\n        runs.push({\n            base: buffer[0],\n            baseSize: BigInt(8),\n            elements: [...buffer].map((value, i) => ({\n                base: buffer[0],\n                size: BigInt(0),\n                tag: makeTag(BigInt(i), BigInt(0b0001), buffer[0]),\n                value,\n            })),\n            encoding: BigInt(0b0000),\n            name: \"repeated_values\",\n            size: BigInt(8),\n        })\n    }\n\n    const baseDeltaRuns: CompressedOutput[] = configs.flatMap((config) => {\n        const value = compressWith(elements, config)\n        if (value === undefined) {\n            return []\n        }\n        return [\n            {\n                ...value,\n                encoding: config.encoding,\n                name: config.name,\n            },\n        ]\n    })\n    const compressed = [...runs, ...baseDeltaRuns].reduce(\n        (prev, curr) =>\n            (prev?.size ?? Number.MAX_SAFE_INTEGER) >\n            (curr?.size ?? Number.MAX_SAFE_INTEGER)\n                ? curr\n                : prev,\n        undefined as CompressedOutput | undefined,\n    )\n\n    if (compressed === undefined) {\n        console.log(\"couldn't find good compression\")\n        return undefined\n    }\n\n    console.log(compressed.name)\n    return compressed\n}\n\nexport const compress = (buffer: BigUint64Array): CompressedOutput =>\n    tryCompress(buffer) ?? {\n        base: BigInt(0),\n        baseSize: BigInt(0),\n        elements: [...buffer].map((value, i) => ({\n            base: undefined,\n            size: BigInt(0x8),\n            tag: makeTag(BigInt(i), BigInt(0b1111), BigInt(0)),\n            value,\n        })),\n        encoding: BigInt(0b1111),\n        name: \"no_compression\",\n        size: BigInt(buffer.length) * BigInt(8),\n    }\n\nexport const toArray = (compressed: ReturnType<typeof compress>) => {\n    const out = compressed.elements.map((element) => element.value)\n\n    const actualLength = new Uint8Array(\n        compressed.elements.flatMap((element) =>\n            toBytes(element.value, element.size),\n        ),\n    ).length\n    const expectedLength = Number(compressed.size - compressed.baseSize)\n    if (actualLength !== expectedLength) {\n        throw new Error(\n            `[toArray]: Expected byte length to be ${expectedLength} but is ${actualLength}`,\n        )\n    }\n    return [\n        ...(compressed.encoding === BigInt(0b1111) ? [] : [compressed.base]),\n        ...out,\n    ]\n}\n\nexport const toByteArray = (compressed: ReturnType<typeof compress>) => {\n    const out = new Uint8Array([\n        ...toBytes(compressed.base, compressed.baseSize),\n        ...compressed.elements.flatMap((element) =>\n            toBytes(element.value, element.size),\n        ),\n    ])\n\n    const actualLength = out.length\n    const expectedLength = Number(compressed.size)\n    if (out.length !== Number(compressed.size)) {\n        throw new Error(\n            `[toByteArray with encoding ${compressed.encoding.toString(\n                2,\n            )}]: Expected byte length to be ${expectedLength} but is ${actualLength}`,\n        )\n    }\n    return out\n}\n\nconst arrayBufferToBigInt = (buf: ArrayBufferLike) => {\n    const hex: string[] = []\n\n    for (const i of new Uint8Array(buf)) {\n        let h = i.toString(16)\n        if (h.length % 2) {\n            h = \"0\" + h\n        }\n        hex.push(h)\n    }\n\n    return BigInt(\"0x\" + (hex.join(\"\") || \"0\"))\n}\n\nexport const decompress = (buffer: ArrayBufferLike, tag: bigint) => {\n    const {encoding, index, isZeroBase} = processTag(tag)\n\n    switch (encoding) {\n        case BigInt(0b0000):\n            return BigInt(0)\n        case BigInt(0b0001):\n            return new BigUint64Array(buffer.slice(0, 8))[0]\n        default:\n            const config = configs.find(\n                (config) => config.encoding === encoding,\n            )\n            if (config === undefined) {\n                throw new Error()\n            }\n\n            const base = isZeroBase\n                ? BigInt(0)\n                : arrayBufferToBigInt(buffer.slice(0, Number(config.baseSize)))\n            const start = config.baseSize + index * config.deltaSize\n            const end = start + config.deltaSize\n            const delta = arrayBufferToBigInt(\n                buffer.slice(Number(start), Number(end)),\n            )\n            return base + delta\n    }\n}\n","export const zip = <A, B>(a: A[], b: B[]) => {\n    const array: [A, B][] = []\n    for (let i = 0; i < Math.max(a.length, b.length); ++i) {\n        array.push([a[i], b[i]])\n    }\n    return array\n}\n","import {compress, decompress, toByteArray} from \"./compress\"\nimport {zip} from \"./util\"\n\nconst i2hex = (i: number) => (\"0\" + i.toString(16)).slice(-2)\n\n/* eslint-env: browser */\n;(window as any).compress = () => {\n    try {\n        const inputBytes = (document.querySelector(\"#compressInput\") as\n            | HTMLTextAreaElement\n            | undefined)?.value\n        if (!inputBytes) {\n            alert(\"Input bytes must be set!\")\n            return\n        }\n\n        const buffer = new BigUint64Array(\n            inputBytes.split(\"\\n\").map((line) => BigInt(line.trim())),\n        )\n        const output = compress(buffer)\n\n        const outputElement = document.querySelector(\"#compressOutput\") as\n            | HTMLTextAreaElement\n            | undefined\n        if (!outputElement) {\n            alert(\"could't find output element\")\n            return\n        }\n\n        const hex = Array.from(toByteArray(output))\n            .map((value) => i2hex(value))\n            .join(\"\")\n\n        let extra = `BASE = 0x${output.base.toString(16)}\\nElements:\\n`\n        let i = 0\n        for (const [{tag, value, base}, initial] of zip(\n            output.elements,\n            Array.from(buffer),\n        )) {\n            extra += `[${i++}] 0x${initial.toString(\n                16,\n            )} is stored as 0x${value.toString(16)} with tag 0x${tag.toString(\n                16,\n            )}`\n            if (base !== undefined) {\n                extra += ` and the base 0x${base.toString(16)}`\n            }\n            extra += \"\\n\"\n        }\n\n        const init = `${\n            output.name === \"no_compression\" ? \"\" : \"Compressed with \"\n        }${output.name}: ${hex}`\n        const sizes = `Input Size: ${\n            buffer.byteLength\n        } bytes\\nCompressed size: ${output.size} bytes (${\n            BigInt(buffer.byteLength) - output.size\n        } bytes saved)`\n        outputElement.value = `${init}\\n\\n${sizes}\\n\\n${extra}`\n    } catch (e) {\n        alert(e.message)\n    }\n}\n;(window as any).decompress = () => {\n    try {\n        const input = document.querySelector(\"#decompressInput\") as\n            | HTMLTextAreaElement\n            | undefined\n        const tag = document.querySelector(\"#decompressTag\") as\n            | HTMLInputElement\n            | undefined\n        const output = document.querySelector(\"#decompressOutput\") as\n            | HTMLTextAreaElement\n            | undefined\n        if (!input || !tag || !output) {\n            alert(\"Couldn't find input element\")\n            return\n        }\n\n        const fromHexString = (hexString: string) =>\n            new Uint8Array(\n                hexString.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) ??\n                    [],\n            )\n\n        const value = decompress(fromHexString(input.value), BigInt(tag.value))\n        output.value = `0x${value.toString(16)}`\n    } catch (e) {\n        alert(e.message)\n    }\n}\n"]}